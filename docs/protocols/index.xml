<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protocols on</title><link>https://pkel.github.io/cpr/docs/protocols/</link><description>Recent content in Protocols on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://pkel.github.io/cpr/docs/protocols/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview</title><link>https://pkel.github.io/cpr/docs/protocols/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/overview/</guid><description>This sections contains a number of protocol specifications. One page per specification. Each specification starts with a short intuition section, briefly describing how the protocol works, what it tries to solve, and how it relates to others. It follows the specification itself, written out as a Python program. These programs are meant for human consumption. Read them to understand them. Do not copy them into an interpreter. The protocol specification methodology page get&amp;rsquo;s you going.</description></item><item><title>Nakamoto</title><link>https://pkel.github.io/cpr/docs/protocols/nakamoto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/nakamoto/</guid><description>Intuition #
The &amp;ldquo;original&amp;rdquo; proof-of-work consensus protocol. Miners build a linear chain of blocks (blockchain). Each block refers to exactly one parent block by including the parents hash. Appending a new block requires a proof-of-work. Miners always try to extend the longest chain. The number of predecessors of a block is called height.
Example #
%% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee A([h]) B([h&amp;#43;1]) CA([h&amp;#43;2]):::orphan CB([h&amp;#43;2]) D([h&amp;#43;3]) EA([h&amp;#43;4]) EB([h&amp;#43;4]):::orphan F([h&amp;#43;5]) G([h&amp;#43;6]) CA --&amp;gt; B --&amp;gt; A EB --&amp;gt; D --&amp;gt; CB --&amp;gt; B G --&amp;gt; F --&amp;gt; EA --&amp;gt; D linkStyle 0,2 opacity:0.</description></item><item><title>Parallel PoW (simplified)</title><link>https://pkel.github.io/cpr/docs/protocols/parallel-simple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/parallel-simple/</guid><description>Intuition #
Nakamoto consensus enforces a linear chain of blocks. Of any two blocks with equal height, only one will be retained. The others get orphaned. Network-level attackers can strategically time message delivery such that the defenders produce more orphans. When the attacker engages with the defenders in a race for the longest chain, orphans effectively slow down the defender and the attacker becomes stronger. Parallel proof-of-work minitages this problem by introducing parallelism where Nakamoto&amp;rsquo;s blockchain is strictly linear.</description></item><item><title>Parallel PoW (AFTâ€‰'22)</title><link>https://pkel.github.io/cpr/docs/protocols/parallel-aft22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/parallel-aft22/</guid><description>Intuition #
Relative to the simplified version, this protocol saves one proof-of-work per block. Unlike in the simplified version, blocks do not require a proof-of-work. Only the votes are mined. The protocol restricts appending new blocks to temporally elected leaders. The leader is the miner who contributes the smallest vote, where size refers to the hash of the vote.
Leadership is verified using cryptographic signatures. Miners include their public key in each vote.</description></item><item><title>Tree-Structured Voting</title><link>https://pkel.github.io/cpr/docs/protocols/parallel-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/parallel-tree/</guid><description>Intuition #
This protocol extends the simplified version of parallel proof-of-work with tree-structured voting. We allow votes to link back to other votes, where previously they could only link back to blocks. This tree structure enables a new incentive scheme where non-linearities are punished fairly.
The new protocol maintains parallel proof-of-work&amp;rsquo;s core property: votes which confirm the same parent block are compatible and can be used together to build the next block.</description></item><item><title>Tailstorm</title><link>https://pkel.github.io/cpr/docs/protocols/tailstorm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pkel.github.io/cpr/docs/protocols/tailstorm/</guid><description>Intuition #
Tailstorm is an improved version of tree-structured voting where the blocks that summarize finished rounds of voting do not require a separate proof-of-work. Summaries can be computed deterministically from the summarized votes. Nodes can re-produce summaries locally, hence they do not have to be communicated over the (latent) network.
Tailstorm uses two kinds of blocks &amp;laquo;sub-blocks&amp;raquo; and &amp;laquo;summmaries&amp;raquo;. Sub-blocks are what was called &amp;laquo;vote&amp;raquo; in tree-structured voting. Sub-blocks have exactly one parent and they require a proof-of-work.</description></item></channel></rss>