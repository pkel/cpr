var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/cpr/docs/prologue/introduction/",title:"Introduction",description:`CPR provides tools for specifying, simulating, and attacking
proof-of-work consensus protocols like Bitcoin and Ethereum.
`,content:`Get started #There are different ways for getting started, depending on what you want to do.
Unfortunately, documentation is lacking for all of them. At some point I want to provide tutorials the following use-cases.
Evaluate existing protocols in a virtual environment. Evaluate existing attacks in a virtual environment. Search attacks against existing protocols using reinforcement learning. Specification of protocols. Specification of attack spaces. If you want to start now, don\u0026rsquo;t hesitate to contact me for support.
`}),e.add({id:1,href:"/cpr/docs/prologue/",title:"Prologue",description:"Prologue CPR.",content:""}),e.add({id:2,href:"/cpr/docs/prologue/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:`Proof-of-stake, do you plan support? #I have not tried to specify proof-of-stake protocols in CPR. My intuition is that some variants of proof-of-stake could be represented with no or only small changes to the current virtual environment. E.g., access to local clock might be sufficient. We could also add support for verifiable random functions (VRFs) and verifiable delay functions (VDFs).
However, this project already has a lot of loose ends. Currently I have no capacity to think about proof-of-stake.
How can I contact you? #Please don\u0026rsquo;t hesitate. You\u0026rsquo;ll find my mail address in my GitHub profile. For public communication, consider creating a new issue.
`}),e.add({id:3,href:"/cpr/docs/methods/",title:"Methodology",description:"CPR Methodology.",content:""}),e.add({id:4,href:"/cpr/docs/methods/virtual-environment/",title:"Virtual Environment",description:`Execution model for proof-of-work protocols.
`,content:`CPR\u0026rsquo;s core component is a network simulation engine for proof-of-work protocols. The engine takes a protocol specification and a network topology as input, then simulates the execution of the protocol in the network over time. In this document we will focus on the theoretical aspects of this virtual environment. We will describe what we simulate and why but not how. In other words, we will define a model for virtual protocol execution.
Distributed Systems #From a technical perspective, proof-of-work blockchains are distributed systems. The individual system participants are called nodes. Nodes maintain local state and communicate with each other through messages over an existing network. The protocol specifies how the nodes behave, that is, how they update their state and what messages they send. It is useful to think of each node as one physical machine.
On the conceptual layer we have to deal with the nodes\u0026rsquo; operators. In some settings\u0026mdash;let\u0026rsquo;s say for a distributed database deployed within a corporation\u0026mdash;it\u0026rsquo;s sufficient to model a single operator who deploys all nodes. In such a setting, one may assume that all nodes follow the protocol specification. Sure, a node may stop being responsive due to network congestion, hardware problems, or power outages, but it will not arbitrarily deviate from the protocol. In distributed systems literature, this is often called the fail-stop model or model of benign failures.
For proof-of-work protocols the fail-stop model is not sufficient. Anybody can add and remove nodes as they want. Consequently, we have to assume that some nodes deviate from the protocol\u0026mdash;usually in order to maximize the operator\u0026rsquo;s own benefits. Usually it\u0026rsquo;s quite hard to pin down what deviations are possible or make sense. In order to be on the safe side, we have to consider arbitrary deviations. Highlighting the difference to benign failures, arbitrary deviations are often called Byzantine faults. The discipline around building protocols that work in in the presence of Byzantine faults is called Byzantine Fault Tolerance (BFT).
When we say a node is honest or benign, we mean that it follows the protocol as specified. Nodes that deviate from the protocol are called malicious nodes. Attackers are operators who deploy malicious nodes. Defenders are operators who deploy honest nodes.
It is quite obvious that any distributed system stops working as indented when there are too many malicious nodes. In the extreme case, all nodes deviate from the protocol and there is nothing to defend. So, distributed system security always starts with assumptions which limit the attacker. In traditional distributed systems one would limit the number of malicious nodes. In proof-of-work systems we limit the hash-rate of the attacker.
ðŸ‘‰ No security without assumptions! When strategic deviations from the protocol are plausible, strategic manipulation of the underlying network is plausible as well. Some attackers might have sufficient resources to slow down or even prevent communication between the defenders. Again, a super strong network-level attacker can bring down any distributed system. In the most extreme case the honest nodes cannot communicate at all and hence the distributed system does not really exist.
Choosing the right assumptions is difficult. Make them too weak and no useful property can be achieved. Make them too strong and they become unrealistic. Smart attackers will violate our assumptions whenever possible.
We postpone making concrete assumptions to the analysis phase of individual protocols. At this point, we make only minimal assumptions about the execution model. We assume there are nodes but not how many. We assume that proof-of-work slows down all nodes, but we do not yet limit the attacker\u0026rsquo;s hash-rate. We assume that all nodes can send and receive messages, but we do not yet limit the propagation delays.
Blobs, Hashes, Blockchain #In practice, nodes are computers. They manipulate binary data locally and send binary data over a network for communication. The central data structure of proof-of-work protocols is the hash-linked list. Blobs of data can refer to other blobs by including a hash of the referenced blob. The hash-function is practically collision-free, which makes the list effectively append-only. It\u0026rsquo;s always possible to append a blob to another, thereby extending (or forking) the list. But it is never possible to edit referenced blobs. Any change to a blob changes its hash. Any blob referring to the old version of the changed blob still includes the old hash and thus refers to the unmodified blob.
In theory, we do not want to deal with binary data and thus introduce an abstraction for blobs and hash-linking. We reuse the prevalent terminology. Blobs are now blocks. Each block can have an arbitrary number of parent blocks (including none), modelling what we called hash-links above. If block \$a\$ is a parent of block \$b\$, then block \$b\$ is a child of block \$a\$. Blocks that can be reached with the parent relationship from block \$a\$ are called ancestors of \$a\$. Blocks that can be reached with the child relationship from block \`a\` are called descendants of \`a\`. Blocks can store arbitrary data in named fields. Blocks, their parents, and their fields are persistent. That is, changing a block creates a copy of the block. Freshly copied blocks do not have any descendants.
Blocks and the parent relationship form a directed acyclic graph which we call block DAG. Within the DAG, blocks without parents are called roots. Blocks without children are called leaves. Looking at the DAG from roots to children, a parent block clearly comes before its children, but children of the same parents (siblings) have the same rank. We say the DAG imposes a partial order on the blocks.
Each block also defines a blockchain, namely the block itself and all its ancestors. Blockchains have exactly one leave, which we sometimes refer to as tip of the chain.
%% Rendering this graph requires Javascript. graph RL b0[root] b1[block] --\u0026gt; b0 b2[block] --\u0026gt; b1 b3[block] --\u0026gt; b1 b4[block] --\u0026gt; b2 \u0026amp; b3 b5[block] --\u0026gt; b1 \u0026amp; b4 b6[block] --\u0026gt; b5 b10[tip] --\u0026gt; b6 classDef orphan opacity:0.5,fill:gray b7[leave]:::orphan --\u0026gt; b5 b8[block]:::orphan --\u0026gt; b0 b9[leave]:::orphan --\u0026gt; b8 \u0026amp; b3 linkStyle 9,10,11,12 opacity:0.5, stroke:gray Block DAG example. Boxes are blocks and arrows indicate the parent-child relationship. Parents are placed left of their children, highlighting the DAG\u0026rsquo;s partial order. A single root is on the far left and we\u0026rsquo;ve marked a tip on the far right. Blocks outside the corresponding blockchain are painted gray. Visibility and Communication #In practice, verifying hash-links requires full knowledge of the referenced blob. Without knowing the blob, its hash cannot be computed. Without knowing the hash, the blob cannot be referred to. It is impossible to distinguish between a link that was intentionally broken\u0026mdash;let\u0026rsquo;s say by replacing the hash with a random number\u0026mdash;and a link to an existing but locally unavailable blob.
For the virtual environment, we introduce the concept of local block visibility. Each block can be either visible to a node or not. Blocks that are locally visible to a node will stay locally visible to this node forever. If a block is locally visible, then all its ancestors are also locally visible. This restriction does not apply to block children where we local visibility might be partial.
In other words, we assume that nodes have partial knowledge about the block DAG. A node\u0026rsquo;s knowledge grows over time as it learns about new blocks in the order imposed by the DAG.
Nodes can create blocks. For this, all parents must be locally visible. Freshly created blocks are invisible to all nodes but their creator. Nodes can decide to share blocks. Depending on the communication assumptions (made elsewhere), the virtual environment makes visible shared blocks, including all their ancestors, to the other nodes. Typically, blocks which have never been shared, and whose descendants have not been shared, will not be visible to any nodes but its creator. We say these blocks are withheld by their creator. Usually, honest nodes do not withhold blocks but malicious nodes do.
We model the determinism of hash-linked lists by allowing nodes to re-create blocks. If two nodes create two identical blocks\u0026mdash;that is, blocks with the same parents, the same fields, and the same field contents\u0026mdash;then only one block is created and both nodes obtain visibility of the same block.
Proof-of-Work #In practice, proof-of-work is about finding blobs that have a small hash. Typically, the protocol sets a difficulty target or number of leading zeros the hash must have. Good hash-functions ensure that finding such blobs is computationally expensive. The only viable solving algorithm is repeated trial and error: modify the blob, calculate the hash, count the leading zeroes, repeat while the difficulty target is not met.
We avoid these expensive computations in our virtual environment. Instead, each block gets an additional property, whether it has a proof-of-work or not, which can be set only by the environment, not by the nodes themselves. Blocks with a proof-of-work are unique, that means they cannot be re-created by appending a block with the same parents and fields.
Then, the virtual environment chooses which nodes succeed when at proof-of-work. Whenever a node succeeds, the environment obtains from the node a block proposal (parents, fields, and field contents), creates the corresponding block, sets the proof-of-work property to true, and then makes visible the new block to the selected node. We now refer to the selected node as the miner of the new block.
Exact assumptions about the timing and selection of nodes are made elsewhere. Typically, the time between consecutive mining events is exponentially distributed with rate \$\\lambda\$. The expected puzzle solving time is \$\\lambda^{-1}\$. Nodes are selected at random with weighted probabilities. While \$\\lambda\$ models the overall hash-rate in the network, the weights model the distribution of hash-rate among the participants. The attacker\u0026rsquo;s hash-rate, that is, the sum of the malicious nodes\u0026rsquo; weights, is at most \$\\alpha\$.
`}),e.add({id:5,href:"/cpr/docs/methods/protocol-specification/",title:"Protocol Specification",description:`How to read protocol specifications.
`,content:`Protocol designers write protocol specifications for consumption by analysts and engineers. The engineer reads the specification and implements it. The analysts reads the specification and tries to find attacks or rule them out. Both analysts and engineers want to interpret the specification as intended by the designer. Practically minded attackers will attack an implementation, not the specification.
Depending on the context, we take the role of the designer or the analysts. We never take the role of the engineer or the practically minded attacker. When we discuss attacks, we generally assume that engineers implement the protocol as specified.
We specify protocols in pseudo-code. That is, we write protocols as programs but these programs are meant for human consumption. We prefer readability over elegance and elegance over efficiency. We use Python\u0026rsquo;s syntax and core functionality hoping that this makes our protocol specifications accessible to a wide audience.
A protocol specification consists of at least five functions: roots, validity, init, update and mining. The first two, roots and validity specify the structure of the protocol\u0026rsquo;s blockchain. The other three, init, update and mining, specify the node. (Go back to the previous section again, if you are confused by the term \u0026laquo;node\u0026raquo;).
The protocol specification might list additional functions for internal use by other functions or to specify difficulty adjustment and reward schemes. For now, we will focus on the core functionality and the five functions mentioned above.
Blockchain #Protocols specify and use a global, append-only data-structure. A-priori, blocks form a directed acyclic graph (DAG). Each block has an arbitrary number of parent blocks and can store arbitrary data. The validity function then restricts what blocks can be appended and thereby imposes a certain structure on the DAG.
The validity function takes a block as argument. It may return True or False, or it may fail. The specification consumer must ensure that all appended blocks are valid, that is, validity returns True.
def validity(b: Block): assert len(b.parents()) == 1 assert b.has_pow() assert b.height == b.parents()[0].height + 1 return True The validity function of Nakamoto consensus specifies that each block has exactly one parent, that each block has a proof-of-work, and that a block\u0026rsquo;s height is the parent\u0026rsquo;s height plus one. The first rule restricts the DAG to be a tree. Protocol designers may specify an initial set of blocks which do not have to be valid. This is done in the specification\u0026rsquo;s roots function. It takes no argument and returns a list of blocks. The specification consumer must ensure that these blocks are part of the DAG when protocol executions begins.
def roots(): return [Block(height=0, miner=None)] Nakamoto consensus has a single root block, often called \u0026laquo;genesis\u0026raquo;. It does not have any parent blocks and its height is zero. Node #The blockchain, as defined by roots and validity, is a global data-structure. But nodes act on local knowledge. They might see only a subset of the blockchain depending on what information the other nodes share, when they share it, and how messages propagate through the network.
Nodes are specified with three functions init, update, and mining.
init takes a list of blocks as argument and returns the node\u0026rsquo;s initial state. The specification consumer must ensure that the list of blocks given to init is the list of blocks defined by the global roots function.
def init(roots: [Block]): return roots[0] Nakamoto consensus nodes use as state their preferred tip of the chain. Initially they prefer the genesis block. update informs the node about new blocks. It takes as argument the node\u0026rsquo;s old state, the new block, and a string indicating how the new block became visible locally. It returns a new state, a list of blocks to share, and a list of blocks to append without proof-of-work. The protocol designer must ensure that
update is called on all blocks as they become locally visible, the new block given as argument and all its ancestors are locally visible, the returned state will be given as first argument to the next update, the to-be-shared blocks are validated and sent to the other nodes, the to-be-appended blocks are validated, appended to the global block DAG, and made visible locally, the event argument is \u0026quot;mining\u0026quot; if the new block was mined locally, the event argument is \u0026quot;append\u0026quot; if the new block was appended locally without proof-of-work, and the event argument is \u0026quot;network\u0026quot; if the new block was received from the network. def update(old: Block, new: Block, event: string): if event == \u0026#34;mining\u0026#34;: return Update(state=new, share=[new]) # implicitly: append = [] elif new.height \u0026gt; old.height: return Update(state=new) # implicitly: share \u0026amp; append = [] else: return Update(state=old) In Nakamoto consensus nodes always prefer the longest chain of blocks, measured by block-height. Newly mined blocks are shared immediately with the other participants. mining defines what the node appends if successful at proof-of-work. The function takes as argument the current state of a node and returns the block that the node wants to mine on. The engineer who implements the specification and the protocol analyst interpret this function differently.
The engineer will implement a proof-of-work loop that each node runs locally in the background. For each iteration of the loop, the node takes the latest block proposal from the mining function, slightly permutes it, calculates its hash, and checks whether the hash meets the mining difficulty target. If yes, the block now has a proof-of-work and becomes valid. The node handles the new block according to the specification\u0026rsquo;s update function.
The analyst avoids doing the actual proof-of-work and just assumes that random nodes succeed with mining at random times. Only when a node succeeds, the analyst obtains a block from the mining function, sets its has_pow() property to true, and updates the node with the newly appended block.
The protocol designer is indifferent to this distinction. She assumes that
b.has_pow() is true if and only if b was appended through proof-of-work, and when a node learns about a successful proof-of-work with update(old_state, new_block, event = \u0026quot;mining\u0026quot;) it holds that new_block == mining(old_state). def mining(b: Block): return Block(height=b.height + 1, parents=[b], miner=Env.my_id) In Nakamoto consensus all blocks require a proof-of-work. Nodes mine to append new blocks to their preferred tip of the chain. Miners include their ID to facilitate disbursement of mining rewards. Difficulty Adjustment #Proof-of-work intentionally slows down the creation of new blocks and hence the growth of the blockchain. Typical proof-of-work protocols try to maintain a constant growth rate. For example, Bitcoin tries to achieve 6 blocks per hour, by updating the proof-of-work puzzle difficulty every 2016 blocks. We use the term difficulty adjustment (DA) to refer to the general problem of controlling chain growth. Concrete DA mechanisms are called difficulty adjustment algorithms (DAA).
Designing DAAs is quite challenging. A good DAA reacts quickly and correctly to changes in the networks true hash-rate. Unfortunately, the true hash-rate cannot be observed. In practice, nodes add a timestamp to each block. The DAA then estimates the current hash-rate from past timestamps. From there it deterministically adjusts the difficulty for future blocks. In this scheme, there are many sources of error. First, mining is a stochastic process. Puzzle solving times are exponentially distributed, implying high variance. Observations of puzzle solving time are noisy. Second, nodes are distributed around the planet and might disagree about the current time. Third, nodes might try to intentionally confuse the DAA by lying about the current time. Forth, timestamps in orphaned blocks cannot be used. In short, difficulty adjustment is a complex control problem. It even has its own line of research.
Luckily, DA is somewhat orthogonal to consensus. In practice, proof-of-work protocols require a DAA but in theory can often get away without. Depending on the analysis, we either assume that the true hash-rate is constant and known or we assume that the DAA does a perfect job. To support the latter, protocols designers have to specify what kind of growth the DAA should control for. In Bitcoin, the growth rate equals increase in block height per time. Other protocols might choose a different metric.
The protocol specification defines a single function progress that maps a given block (tip of blockchain) to a scalar value. The engineer implementing the protocol will contribute a DAA that controls for constant progress per time. The analyst sometimes assumes constant progress per time.
def progress(b: Block): return b.height Nakamoto consensus uses the block height as progress. The DAA tries to achieve constant progress per time. Bitcoin targets 6 blocks per hour. Rewards #Deployed blockchain protocols usually implement some sort of virtual currency. Funds are associated with cryptographic key-pairs. Moving funds from one key-pair to another requires access to the source key-pair\u0026rsquo;s private part. This introduces a new kind of system participant, namely the holders of the private keys and hence \u0026laquo;owners\u0026raquo; of the associated funds. We call them crypto-currency users.
In principle, crypto-currency users and node operators can be disjunct. Users may operate a node but they do not have to. But in practice, blockchain protocols motivate participation as operator by handing out crypto-currency denoted rewards. Hence node operators usually are crypto-currency users.
As protocol designers, we want our protocol to accommodate as many applications as possible. We avoid imposing requirements on the crypto-currency. We just assume that each node has access to a unique identifier my_id that can receive rewards. In practice, my_id would be the account or wallet address of the node\u0026rsquo;s operator. The specification itself however does not have any notion of crypto-currency address or wallet.
We specify reward calculation using four functions local_tip, global_tip, history and reward.
local_tip takes a node\u0026rsquo;s state as argument and returns its preferred tip of the chain. global_tip selects the impartially best tip among all nodes\u0026rsquo; preferred tips. history calculates the linear history of the best tip. reward maps a block (in the linear history) to reward assignments. A reward assignment assigns a scalar reward to a node id. def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): if l[i].height \u0026gt; b.height: b = l[i] return b def history(b: Block): h = [b] p = b.parents() while p != []: h.append(p[0]) p = p[0].parents() return h def reward(b: Block): return [Reward(b.miner, 1)] In Nakamoto consensus the node\u0026rsquo;s state is its preferred tip of the chain. The best tip is the longest chain. The history is the blockchain itself and the rewards are constant. Splitting reward calculation into these four functions enables us to calculate different useful metrics like
subjective rewards for each node, objective rewards in case of disagreement, individual rewards for each block, and accumulated historic rewards per node for any tip of the chain. The reward API can model situations where miners get assigned rewards for blocks that are not part of the linear history. This happens for example in tree-structured voting.
`}),e.add({id:6,href:"/cpr/docs/protocols/",title:"Protocols",description:"CPR built-in protocols.",content:""}),e.add({id:7,href:"/cpr/docs/protocols/overview/",title:"Overview",description:`Overview about the specified protocols.
`,content:`This sections contains a number of protocol specifications. One page per specification. Each specification starts with a short intuition section, briefly describing how the protocol works, what it tries to solve, and how it relates to others. It follows the specification itself, written out as a Python program. These programs are meant for human consumption. Read them to understand them. Do not copy them into an interpreter. The protocol specification methodology page get\u0026rsquo;s you going.
If you want to study the protocols in-order, we recommend following the dependency graph below. If you just read the obligatory methodology section, you\u0026rsquo;ve learned about Nakamoto consensus along the lines. You are ready for parallel voting.
%% Rendering this graph requires Javascript. graph TD nc[Nakamoto Consensus] ps[\u0026#34;Parallel Proof-of-Work (simplified)\u0026#34;] psaft[\u0026#34;Parallel Proof-of-Work (AFT \u0026#39;22)\u0026#34;] tree[\u0026#34;Tree-Structured Voting\u0026#34;] ts[\u0026#34;Tailstorm\u0026#34;] nc --\u0026gt; ps --\u0026gt; psaft ps --\u0026gt; tree --\u0026gt; ts click nc \u0026#34;../nakamoto\u0026#34; click ps \u0026#34;../parallel-simple\u0026#34; click psaft \u0026#34;../parallel-aft22\u0026#34; click tree \u0026#34;../parallel-tree\u0026#34; click ts \u0026#34;../tailstorm\u0026#34; Suggested order for studying the specified protocols. Click on a node to jump to the protocol specification page! `}),e.add({id:8,href:"/cpr/docs/protocols/nakamoto/",title:"Nakamoto",description:`Satoshi Nakamoto's consensus protocol as deployed in Bitcoin.
`,content:`Intuition #The \u0026ldquo;original\u0026rdquo; proof-of-work consensus protocol. Miners build a linear chain of blocks (blockchain). Each block refers to exactly one parent block by including the parents hash. Appending a new block requires a proof-of-work. Miners always try to extend the longest chain. The number of predecessors of a block is called height.
Example #%% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee A([h]) B([h\u0026#43;1]) CA([h\u0026#43;2]):::orphan CB([h\u0026#43;2]) D([h\u0026#43;3]) EA([h\u0026#43;4]) EB([h\u0026#43;4]):::orphan F([h\u0026#43;5]) G([h\u0026#43;6]) CA --\u0026gt; B --\u0026gt; A EB --\u0026gt; D --\u0026gt; CB --\u0026gt; B G --\u0026gt; F --\u0026gt; EA --\u0026gt; D linkStyle 0,2 opacity:0.5 Boxes represent blocks, arrows represent hash-references. Each block has exactly one parent. Appending a new block requires proof-of-work. The gray blocks are orphaned. Specification #Have a look at the methodology page for protocol specification to learn how to read this.
Blockchain #def roots(): return [Block(height=0, miner=None)] def validity(b: Block): assert len(b.parents()) == 1 assert b.has_pow() assert b.height == b.parents()[0].height + 1 return True Node #def init(roots: [Block]): return roots[0] def update(old: Block, new: Block, event: string): if event == \u0026#34;mining\u0026#34;: return Update(state=new, share=[new]) elif new.height \u0026gt; old.height: return Update(state=new) else: return Update(state=old) def mining(b: Block): return Block(height=b.height + 1, parents=[b], miner=Env.my_id) Difficulty Adjustment #def progress(b: Block): return b.height Rewards #def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): if l[i].height \u0026gt; b.height: b = l[i] return b def history(b: Block): h = [b] p = b.parents() while p != []: h.append(p[0]) p = p[0].parents() return h def reward(b: Block): return [Reward(b.miner, 1)] %% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee A([1]) B([1]) CA([n/a]):::orphan CB([1]) D([1]) EA([1]) EB([n/a]):::orphan F([1]) G([1]) CA --\u0026gt; B --\u0026gt; A EB --\u0026gt; D --\u0026gt; CB --\u0026gt; B G --\u0026gt; F --\u0026gt; EA --\u0026gt; D linkStyle 0,2 opacity:0.5 Reward scheme applied to the example blockchain shown above. Each block on the longest chain assign 1 unit of reward to is miner. Literature #The following papers may serve as a starting point.
Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Tech report, 2008. [bitcoin.org] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. Eurocrypt \u0026lsquo;15. [publisher] Dongning Guo and Ling Ren. Bitcoinâ€™s Latency\u0026ndash;Security Analysis Made Simple. AFT \u0026lsquo;22. [preprint] `}),e.add({id:9,href:"/cpr/docs/protocols/parallel-simple/",title:"Parallel PoW (simplified)",description:`Simplified implementation of parallel proof-of-work.
`,content:`Intuition #Nakamoto consensus enforces a linear chain of blocks. Of any two blocks with equal height, only one will be retained. The others get orphaned. Network-level attackers can strategically time message delivery such that the defenders produce more orphans. When the attacker engages with the defenders in a race for the longest chain, orphans effectively slow down the defender and the attacker becomes stronger. Parallel proof-of-work minitages this problem by introducing parallelism where Nakamoto\u0026rsquo;s blockchain is strictly linear.
Parallel proof-of-work distinguishes between blocks and votes. The blocks still form a linear chain, but the votes can be mined in parallel. Votes for the same parent block are compatible, even if their miners cannot communicate. Orphans can only happen at the transition between blocks.
In this simple version of parallel proof-of-work, both blocks and votes require a proof-of-work. Appending a new block requires \$k - 1\$ votes for the previous block. Together with the proof-of-work required for the block itself, this makes \$k\` proofs-of-work per block.
The original version of parallel proof-of-work\u0026mdash;as presented by Keller and BÃ¶hme at AFTâ€‰\u0026lsquo;22\u0026mdash;is a bit more complicated. Make sure you understand this simple version before you explore the AFTâ€‰\u0026lsquo;22 version.
Example #%% Rendering this graph requires Javascript. graph RL b0([h ]) b1([h\u0026#43;1]) --\u0026gt; v0([ ]) \u0026amp; v01([ ]) \u0026amp; v02([ ]) --\u0026gt; b0 b2([h\u0026#43;2]) --\u0026gt; v3([ ]) \u0026amp; v04([ ]) \u0026amp; v05([ ]) --\u0026gt; b1 b3([h\u0026#43;3]) --\u0026gt; v6([ ]) \u0026amp; v07([ ]) \u0026amp; v08([ ]) --\u0026gt; b2 b4([h\u0026#43;3]) --\u0026gt; v9([ ]) \u0026amp; v10([ ]) \u0026amp; v11([ ]) --\u0026gt; b3 Parallel proof-of-work with three votes per block. Idealized case w/o orphans. Blocks are labelled with their height. Votes have no label. Both blocks and votes require a proof-of-work. %% Rendering this graph requires Javascript. graph RL b0([h ]) b1([h\u0026#43;1]) --\u0026gt; v00([ ]) \u0026amp; v01([ ]) \u0026amp; v02([ ]) --\u0026gt; b0 b2([h\u0026#43;2]) --\u0026gt; v03([ ]) \u0026amp; v04([ ]) \u0026amp; v05([ ]) --\u0026gt; b1 b3([h\u0026#43;3]) --\u0026gt; v06([ ]) \u0026amp; v07([ ]) \u0026amp; v08([ ]) --\u0026gt; b2 b4([h\u0026#43;3]) --\u0026gt; v09([ ]) \u0026amp; v10([ ]) \u0026amp; v11([ ]) --\u0026gt; b3 classDef orphan opacity:0.5,fill:#eee o1([ ]):::orphan --\u0026gt; b0 o2([ ]):::orphan --\u0026gt; b1 o3([h\u0026#43;2]):::orphan --\u0026gt; o2 \u0026amp; v05 \u0026amp; v04 o4([h\u0026#43;3]):::orphan --\u0026gt; v06 \u0026amp; v07 \u0026amp; v08 o5([ ]):::orphan --\u0026gt; o4 linkStyle 24,25,26,27,28,29,30,31,32 opacity:0.5 The same parallel proof-of-work blockchain with potential orphans in gray. Specification #Have a look at the methodology page for protocol specification to learn how to read this.
Parameters #k: number of proofs-of-work per block (or number of votes per block plus one)
Blockchain #def roots(): return [Block(height=0, miner=None, kind=\u0026#34;block\u0026#34;)] def parent_block(b: Block): if b.kind == \u0026#34;block\u0026#34;: return b.parents()[0].parents()[0] else: return b.parents()[0] def validity(b: Block): assert b.has_pow() if b.kind == \u0026#34;block\u0026#34;: p = parent_block(b) assert len(b.parents()) == k - 1 assert b.height == p.height + 1 for x in b.parents(): assert x.parents()[0] == p elif b.kind == \u0026#34;vote\u0026#34;: assert len(b.parents()) == 1 return False Node #def init(roots: [Block]): return roots[0] def preference(old: Block, new: Block): assert new.kind == \u0026#34;block\u0026#34; if new.height \u0026gt; old.height: return new if new.height \u0026lt; old.height: return old n_old = len(old.children()) n_new = len(new.children()) if n_new \u0026gt; n_old: return new return old def update(old: Block, new: Block, event: string): if new.kind == \u0026#34;block\u0026#34;: consider = new else: consider = parent_block(new) return Update( state=preference(old, consider), share=[new] if event == \u0026#34;mining\u0026#34; else [], ) def mining(b: Block): assert b.kind == \u0026#34;block\u0026#34; if len(b.children()) \u0026lt; k - 1: return Block(kind=\u0026#34;vote\u0026#34;, parents=[b], miner=my_id) else: # select k - 1 votes; own votes first, then old before new votes = ... return Block( kind=\u0026#34;block\u0026#34;, height=b.height + 1, parents=votes, miner=my_id, ) Difficulty Adjustment #def progress(b: Block): if b.kind == \u0026#34;block\u0026#34;: return b.height * k else: p = parent_block(b) return p.height * k + 1 Rewards #def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): b = preference(b, l[i]) return b def history(b: Block): h = [b] p = b.parents() while p != []: b = p[0] if b.kind == \u0026#34;block\u0026#34;: h.append(b) p = b.parents() return h def reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; return [Reward(x.miner, 1) for x in [b] + b.parents()] %% Rendering this graph requires Javascript. graph RL b0([1]) b1([1]) --\u0026gt; v00([1]) \u0026amp; v01([1]) \u0026amp; v02([1]) --\u0026gt; b0 b2([1]) --\u0026gt; v03([1]) \u0026amp; v04([1]) \u0026amp; v05([1]) --\u0026gt; b1 b3([1]) --\u0026gt; v06([1]) \u0026amp; v07([1]) \u0026amp; v08([1]) --\u0026gt; b2 b4([1]) --\u0026gt; v09([1]) \u0026amp; v10([1]) \u0026amp; v11([1]) --\u0026gt; b3 classDef orphan opacity:0.5,fill:#eee o1([n/a]):::orphan --\u0026gt; b0 o2([n/a]):::orphan --\u0026gt; b1 o3([n/a]):::orphan --\u0026gt; o2 \u0026amp; v05 \u0026amp; v04 o4([n/a]):::orphan --\u0026gt; v06 \u0026amp; v07 \u0026amp; v08 o5([n/a]):::orphan --\u0026gt; o4 linkStyle 24,25,26,27,28,29,30,31,32 opacity:0.5 Blockchain depicted above with reward scheme applied to the longest chain. Each proof-of-work rewards its miner with one unit of reward. Naturally, orphans are not rewarded. Literature #This protocol is a simplified version of the protocol \$\\mathcal B_k\$ presented by Keller and BÃ¶hme.
Keller and BÃ¶hme. Parallel Proof-of-Work with Concrete Bounds. AFTâ€‰\u0026lsquo;22. [preprint] `}),e.add({id:10,href:"/cpr/docs/protocols/parallel-aft22/",title:"Parallel PoW (AFTâ€‰'22)",description:`Parallel proof-of-work protocol as presented at AFTâ€‰'22.
`,content:`Intuition #Relative to the simplified version, this protocol saves one proof-of-work per block. Unlike in the simplified version, blocks do not require a proof-of-work. Only the votes are mined. The protocol restricts appending new blocks to temporally elected leaders. The leader is the miner who contributes the smallest vote, where size refers to the hash of the vote.
Leadership is verified using cryptographic signatures. Miners include their public key in each vote. When they become leader, they sign the proposed block with the private key belonging to the public key in the smallest vote. The other nodes check the signature and thereby verify leadership.
It is worth noting, that this use of cryptographic signatures does not rely on a public key infrastructure (PKI). Key-pairs are associated not with protocol participants but with votes. In fact, each vote could include a unique public key.
Example #%% Rendering this graph requires Javascript. graph RL b0[h ] b1[h\u0026#43;1] --\u0026gt; v00([43]) \u0026amp; v01([92]) \u0026amp; v02([29]) --\u0026gt; b0 b2[h\u0026#43;2] --\u0026gt; v03([40]) \u0026amp; v04([19]) \u0026amp; v05([75]) --\u0026gt; b1 b3[h\u0026#43;3] --\u0026gt; v06([59]) \u0026amp; v07([22]) \u0026amp; v08([52]) --\u0026gt; b2 b4[h\u0026#43;3] --\u0026gt; v09([46]) \u0026amp; v10([64]) \u0026amp; v11([47]) --\u0026gt; b3 v02 --\u0026gt; b1 v04 --\u0026gt; b2 v07 --\u0026gt; b3 v09 --\u0026gt; b4 linkStyle 24,25,26,27 stroke:green Parallel proof-of-work with three votes per block. Blocks have square boxes and are labelled with their height. Votes have round boxes and are labelled with their hash. Only votes require a proof-of-work. Blocks are signed by the voter with the smallest hash, which we indicate using green arrows. Specification #Have a look at the methodology page for protocol specification to learn how to read this.
Parameters #k: number of votes per block
Blockchain #def roots(): return [Block(height=0, miner=None, kind=\u0026#34;block\u0026#34;)] def parent_block(b: Block): if b.kind == \u0026#34;block\u0026#34;: return b.parents()[0].parents()[0] else: return b.parents()[0] def validity(b: Block): parents = b.parents() if b.kind == \u0026#34;block\u0026#34;: p = parent_block(b) assert len(parents) == k assert b.signed_by(parents[0].miner) assert b.height == p.height + 1 for i in range(1, len(parents)): assert parents[i] == p assert parents[i - 1].hash() \u0026lt;= parents[i].hash() elif b.kind == \u0026#34;vote\u0026#34;: assert len(parents) == 1 assert b.has_pow() return False Node #def init(roots: [Block]): return roots[0] def preference(old: Block, new: Block): assert new.kind == \u0026#34;block\u0026#34; if new.height \u0026gt; old.height: return new if new.height \u0026lt; old.height: return old n_old = len(old.children()) n_new = len(new.children()) if n_new \u0026gt; n_old: return new if n_new \u0026lt; n_old: return old if new.children()[0].hash() \u0026lt; old.children()[0].hash(): return new return old def attempt_block(b: Block): assert b.kind == \u0026#34;block\u0026#34; votes = b.children().sort(key=lambda x: x.hash()) while votes[0].miner != my_id: votes.pop(0) if len(votes) \u0026lt; k: return [] # block infeasible else: # select k votes; priotize own votes, then old before new; # maintain hash-ordering votes = ... return [ Block( kind=\u0026#34;block\u0026#34;, height=b.height + 1, parents=votes, sign=True, ) ] def update(old: Block, new: Block, event: string): if new.kind == \u0026#34;block\u0026#34;: return Update( state=preference(old, new), share=[new] if event == \u0026#34;append\u0026#34; else [], ) else: # new.kind == \u0026#34;vote\u0026#34; b = new.children()[0] return Update( state=preference(old, b), share=[new] if event == \u0026#34;mining\u0026#34; else [], append=attempt_block(b), ) def mining(b: Block): assert b.kind == \u0026#34;block\u0026#34; return Block(kind=\u0026#34;vote\u0026#34;, parents=[b], miner=my_id) Difficulty Adjustment #def progress(b: Block): if b.kind == \u0026#34;block\u0026#34;: return b.height * k else: p = parent_block(b) return p.height * k + 1 Rewards #def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): b = preference(b, l[i]) return b def history(b: Block): h = [b] p = b.parents() while p != []: b = p[0] if b.kind == \u0026#34;block\u0026#34;: h.append(b) p = b.parents() return h def reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; return [Reward(x.miner, 1) for x in b.parents()] %% Rendering this graph requires Javascript. graph RL b0[n/a] b1[n/a] --\u0026gt; v00([1]) \u0026amp; v01([1]) \u0026amp; v02([1]) --\u0026gt; b0 b2[n/a] --\u0026gt; v03([1]) \u0026amp; v04([1]) \u0026amp; v05([1]) --\u0026gt; b1 b3[n/a] --\u0026gt; v06([1]) \u0026amp; v07([1]) \u0026amp; v08([1]) --\u0026gt; b2 b4[n/a] --\u0026gt; v09([1]) \u0026amp; v10([1]) \u0026amp; v11([1]) --\u0026gt; b3 v02 --\u0026gt; b1 v04 --\u0026gt; b2 v07 --\u0026gt; b3 v09 --\u0026gt; b4 linkStyle 24,25,26,27 stroke:green Blockchain depicted above with reward scheme applied. Each proof-of-work rewards its miner with one unit of reward, hence only votes assign a reward. Literature #In their presentation, Keller and BÃ¶hme refer to this protocol as \$\\mathcal B_k\$.
Keller and BÃ¶hme. Parallel Proof-of-Work with Concrete Bounds. AFTâ€‰\u0026lsquo;22. [preprint] `}),e.add({id:11,href:"/cpr/docs/protocols/parallel-tree/",title:"Tree-Structured Voting",description:`Simple parallel proof-of-work with tree-structured voting.
`,content:`Intuition #This protocol extends the simplified version of parallel proof-of-work with tree-structured voting. We allow votes to link back to other votes, where previously they could only link back to blocks. This tree structure enables a new incentive scheme where non-linearities are punished fairly.
The new protocol maintains parallel proof-of-work\u0026rsquo;s core property: votes which confirm the same parent block are compatible and can be used together to build the next block. To be clear, tree-structured voting does not change the parallel voting mechanism of the other two parallel protocols, simple and AFTâ€‰\u0026lsquo;22 version.
In the new protocol, miners do not merely vote for the last block, but they vote for the longest chain of votes. Optimally, all votes form a linear chain and we know the exact order in they were mined. Otherwise, the votes form a tree and the ordering of votes is partial.
Recall that ordering is the main objective of proof-of-work consensus protocols. Tree-structured voting motivates forming a linear chain of votes through incentives. The rewards for the votes in a block are scaled down in proportion to the depth of the vote tree. Non-linearity implies reduced reward.
Let\u0026rsquo;s take a step back and recall Nakamoto\u0026rsquo;s original proof-of-work protocol. Also Nakamoto motivates linearity through incentives. Blocks that to not end up on the linear blockchain are orphaned and do not get rewards. In the intuition to the simple parallel protocol we\u0026rsquo;ve seen that orphans are a threat to security. But orphans also cause unfairness with respect to honest behaviour. Imagine a situation where two miners\u0026mdash;one weak (let\u0026rsquo;s say 2% of the hash-rate) and one strong (20% of the hash-rate)\u0026mdash;mine blocks around the same time and create a fork. Obviously, the weak miner tries to confirm her block, the strong miner tries to confirm the other. We do not know what the other miners (72% of the hash-rate) do. If we assume that they are unbiased, that is, they mine one or the other block with equal probability, we end up in a situation were 38% of the hash rate tries to confirm the weak miners block and 62% of the hash rate tries to confirm the strong miners block. Only one of the blocks will end up in the final blockchain. The other does not get rewards. The punishment mechanism for non-linearity is biased in favour of the strong miner.
Tree-structured voting addresses this problem. Here, the reward is discounted on a per-block basis. Non-linearity implies lower rewards but the discount applies to all confirmed votes equally. The punishment bias is removed, at least among the confirmed votes.
Tree-structured voting and the discounting of rewards were originally proposed for the Tailstorm protocol. However, since Tailstorm also does elaborate optimizations, we think it is easier to first study this protocol.
Example #%% Rendering this graph requires Javascript. graph RL b0[h] b1[h\u0026#43;1] --\u0026gt; v3([3]) --\u0026gt; v2([2]) --\u0026gt; v1([1]) --\u0026gt; b0 v5([1]) \u0026amp; v4([1]) --\u0026gt; b1 v6([2]) --\u0026gt; v5 b2[h\u0026#43;2] --\u0026gt; v4 \u0026amp; v6 b3[h\u0026#43;3] --\u0026gt; v9([1]) \u0026amp; v8([1]) \u0026amp; v7([1]) --\u0026gt; b2 b4[h\u0026#43;4] --\u0026gt; v12([2]) \u0026amp; v11([2]) --\u0026gt; v10([1]) --\u0026gt; b3 Tree-structured voting with 3 votes per block. Block have square boxes and are labelled with their height, votes have round boxes and are labelled with their depth. Both votes and blocks require a proof-of-work. %% Rendering this graph requires Javascript. graph RL b0[h] b1[h\u0026#43;1] --\u0026gt; v3([3]) --\u0026gt; v2([2]) --\u0026gt; v1([1]) --\u0026gt; b0 v5([1]) \u0026amp; v4([1]) --\u0026gt; b1 v6([2]) --\u0026gt; v5 b2[h\u0026#43;2] --\u0026gt; v4 \u0026amp; v6 b3[h\u0026#43;3] --\u0026gt; v9([1]) \u0026amp; v8([1]) \u0026amp; v7([1]) --\u0026gt; b2 b4[h\u0026#43;4] --\u0026gt; v12([2]) \u0026amp; v11([2]) --\u0026gt; v10([1]) --\u0026gt; b3 classDef orphan opacity:0.5,fill:gray ob1[h\u0026#43;1]:::orphan --\u0026gt; v3 ov1([2]):::orphan --\u0026gt; v4 ov2([2]):::orphan --\u0026gt; v10 ob4[h\u0026#43;4]:::orphan --\u0026gt; v11 \u0026amp; v12 linkStyle 20,21,22,23,24 opacity:0.5, stroke:gray Orphans are possible, but only when transitioning from one block to the next. These transitions are less frequent if there are more votes per block. Specification #Have a look at the methodology page for protocol specification to learn how to read this.
Parameters #k: number of proofs-of-work per blocks (or number of votes per block plus one)
Blockchain #def roots(): return [Block(height=0, depth=0, miner=None, kind=\u0026#34;block\u0026#34;)] def parent_block(b: Block): b = b.parents()[0] while b.kind != \u0026#34;block\u0026#34;: b = b.parents()[0] return b def confirmed_votes(b: Block): set = {} for p in b.parents(): if p.kind == \u0026#34;vote\u0026#34;: set |= {p} set |= confirmed_votes(p) return set def confirming_votes(b: Block): set = {} for c in b.children(): if c.kind == \u0026#34;vote\u0026#34;: set |= {c} set |= confirming_votes(c) return set def validity(b: Block): assert b.has_pow() if b.kind == \u0026#34;block\u0026#34;: assert b.height == parent_block(b).height + 1 assert b.depth == 0 assert len(confirmed_votes(b)) == k - 1 for x in confirmed_votes(b): assert parent_block(x) == parent_block(b) elif b.kind == \u0026#34;vote\u0026#34;: parents = b.parents() assert len(parents) == 1 assert b.depth == parents[0].depth + 1 return False Node #def init(roots: [Block]): assert len(roots) == 1 return roots[0] def preference(old: Block, new: Block): if new.kind != \u0026#34;block\u0026#34;: new = parent_block(new) if new.height \u0026gt; old.height: return new if new.height \u0026lt; old.height: return old old_votes = confirming_votes(old) new_votes = confirming_votes(new) if len(new_votes) \u0026gt; len(old_votes): return new if len(new_votes) \u0026lt; len(old_votes): return old old_depth = max([x.depth for x in old_votes]) new_depth = max([x.depth for x in new_votes]) if new_depth \u0026gt; old_depth: return new return old def update(old: Block, new: Block, event: string): return Update( state=preference(old, new), share=[new] if event == \u0026#34;mining\u0026#34; else [], ) def mining(b: Block): vote_tree = confirming_votes(b) if len(vote_tree) \u0026lt; k - 1: # block infeasible; extend longest chain of votes opt = b for x in confirming_votes(b): if x.depth \u0026gt; opt.depth: opt = x if x.depth == opt.depth and opt.miner == my_id: opt = x return Block( kind=\u0026#34;vote\u0026#34;, depth=opt.depth + 1, parents=[opt], miner=my_id, ) else: # block feasible # select leaves in vote_tree to confirm k - 1 votes # while maximizing depth leaves = ... return Block( kind=\u0026#34;block\u0026#34;, height=b.height + 1, depth=0, parents=leaves, miner=my_id, ) Difficulty Adjustment #def progress(b: Block): return b.height * k + b.depth Rewards #def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): b = preference(b, l[i]) return b def history(b: Block): h = [b] p = b.parents() while p != []: b = p[0] if b.kind == \u0026#34;block\u0026#34;: h.append(b) p = b.parents() return h Constant reward #def constant_reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; return [Reward(x.miner, 1) for x in {b} | confirming_votes(b)] %% Rendering this graph requires Javascript. graph RL b0[1] b1[1] --\u0026gt; v3([1]) --\u0026gt; v2([1]) --\u0026gt; v1([1]) --\u0026gt; b0 v5([1]) \u0026amp; v4([1]) --\u0026gt; b1 v6([1]) --\u0026gt; v5 b2[1] --\u0026gt; v4 \u0026amp; v6 b3[1] --\u0026gt; v9([1]) \u0026amp; v8([1]) \u0026amp; v7([1]) --\u0026gt; b2 b4[1] --\u0026gt; v12([1]) \u0026amp; v11([1]) --\u0026gt; v10([1]) --\u0026gt; b3 Constant rewards make tree-structured voting equivalent to simple parallel proof-of-work. Discount reward #Tree-style voting opens up a new design space for reward functions that take into account the depth of the vote-tree. Countless variants are possible. We list only a few to provide an intuition.
def discount0_reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; d = max([x.depth for x in b.parents()]) r = (d + 1) / k return [Reward(x.miner, r) for x in {b} | confirmed_votes(b)] %% Rendering this graph requires Javascript. graph RL b0[?] b1[4/4] --\u0026gt; v3([4/4]) --\u0026gt; v2([4/4]) --\u0026gt; v1([4/4]) --\u0026gt; b0 v5([3/4]) \u0026amp; v4([3/4]) --\u0026gt; b1 v6([3/4]) --\u0026gt; v5 b2[3/4] --\u0026gt; v4 \u0026amp; v6 b3[2/4] --\u0026gt; v9([2/4]) \u0026amp; v8([2/4]) \u0026amp; v7([2/4]) --\u0026gt; b2 b4[3/4] --\u0026gt; v12([3/4]) \u0026amp; v11([3/4]) --\u0026gt; v10([3/4]) --\u0026gt; b3 Non-linearity is punished proportionally to the depth of the vote-tree. A block counts as leave in the tree of confirmed votes. We do not see the tree of the leftmost block, thus we cannot calculate its rewards. def discount1_reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; d = max([x.depth for x in b.parents()]) r = (d + 1) / k return [ Reward(x.miner, r) for x in confirmed_votes(b) | parent_block(b) ] %% Rendering this graph requires Javascript. graph RL b0[4/4] b1[3/4] --\u0026gt; v3([4/4]) --\u0026gt; v2([4/4]) --\u0026gt; v1([4/4]) --\u0026gt; b0 v5([3/4]) \u0026amp; v4([3/4]) --\u0026gt; b1 v6([3/4]) --\u0026gt; v5 b2[2/4] --\u0026gt; v4 \u0026amp; v6 b3[3/4] --\u0026gt; v9([2/4]) \u0026amp; v8([2/4]) \u0026amp; v7([2/4]) --\u0026gt; b2 b4[?] --\u0026gt; v12([3/4]) \u0026amp; v11([3/4]) --\u0026gt; v10([3/4]) --\u0026gt; b3 Again, non-linearity is punished proportionally to the depth of the vote-tree. Now, a block counts as root in the tree of confirming votes. We do not see the tree of the rightmost block, thus we cannot calculate its rewards. Compared to the discount0 scheme, only the blocks\u0026rsquo; rewards change. def discount2_reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; r = max([x.depth for x in b.parents()]) / k return [Reward(b.miner, 1)] + [ Reward(x.miner, r) for x in confirmed_votes(b) ] %% Rendering this graph requires Javascript. graph RL b0[1] b1[1] --\u0026gt; v3([3/3]) --\u0026gt; v2([3/3]) --\u0026gt; v1([3/3]) --\u0026gt; b0 v5([2/3]) \u0026amp; v4([2/3]) --\u0026gt; b1 v6([2/3]) --\u0026gt; v5 b2[1] --\u0026gt; v4 \u0026amp; v6 b3[1] --\u0026gt; v9([1/3]) \u0026amp; v8([1/3]) \u0026amp; v7([1/3]) --\u0026gt; b2 b4[1] --\u0026gt; v12([2/3]) \u0026amp; v11([2/3]) --\u0026gt; v10([2/3]) --\u0026gt; b3 Still, non-linearity is punished proportionally to the depth of the vote-tree. Now, the depth-based discount applies to votes only while blocks get constant rewards. def discount3_reward(b: Block): assert b.kind == \u0026#34;block\u0026#34; r = max([x.depth for x in b.parents()]) / k block_rewards = [ Reward(b.miner, r / 2) for x in [b, parent_block(b)] ] vote_rewards = [Reward(x.miner, r) for x in confirmed_votes(b)] return block_rewards + vote_rewards %% Rendering this graph requires Javascript. graph RL b0[?] b1[5/6] --\u0026gt; v3([3/3]) --\u0026gt; v2([3/3]) --\u0026gt; v1([3/3]) --\u0026gt; b0 v5([2/3]) \u0026amp; v4([2/3]) --\u0026gt; b1 v6([2/3]) --\u0026gt; v5 b2[3/6] --\u0026gt; v4 \u0026amp; v6 b3[3/6] --\u0026gt; v9([1/3]) \u0026amp; v8([1/3]) \u0026amp; v7([1/3]) --\u0026gt; b2 b4[?] --\u0026gt; v12([2/3]) \u0026amp; v11([2/3]) --\u0026gt; v10([2/3]) --\u0026gt; b3 As before, non-linearity is punished proportionally to the depth of the vote-tree. The depth-based discount applies to votes like in the discount2 scheme. Here, blocks do not get constant reward but the mean of confirmed and confirming votes. We cannot calculate the rewards for the outermost blocks because they depend on unobserved parts of the blockchain. Needless to say, other hybrids are possible. Tree-structured voting opens up a whole design space for blockchain incentive schemes.
Literature #Some sort of tree-structured voting in present in Bobtail, altough it does not discount rewards depending on the tree structure. Alzayat et al. analyse the inequality of Nakamoto consensus which is the main motivation for the discount reward scheme presented here.
George Bissias and Brian N. Levine. Bobtail: Improved Blockchain Security with Low-Variance Mining. NDSSâ€‰\u0026lsquo;22. [publisher] Mohamed Alzayat and others. Modeling Coordinated vs. P2P Mining: An Analysis of Inefficiency and Inequality in Proof-of-Work Blockchains. [preprint] `}),e.add({id:12,href:"/cpr/docs/protocols/tailstorm/",title:"Tailstorm",description:`Tailstorm consensus protocol. WIP.
`,content:`Intuition #Tailstorm is an improved version of tree-structured voting where the blocks that summarize finished rounds of voting do not require a separate proof-of-work. Summaries can be computed deterministically from the summarized votes. Nodes can re-produce summaries locally, hence they do not have to be communicated over the (latent) network.
Tailstorm uses two kinds of blocks \u0026laquo;sub-blocks\u0026raquo; and \u0026laquo;summmaries\u0026raquo;. Sub-blocks are what was called \u0026laquo;vote\u0026raquo; in tree-structured voting. Sub-blocks have exactly one parent and they require a proof-of-work. Summaries conclude a round of voting by accumulating \$k\$ sub-blocks that all confirm the same parent summary. Summaries do not require a proof-of-work. They are computed deterministically from the \`k\` summarized sub-blocks.
Recall the different viable discount rewards schemes presented for tree-structured voting. There, it was not obvious how to reward the blocks between two rounds of voting. Here, in Tailstorm, the solution is apparent. Summaries do not require additional work, hence we do not hand out rewards for summaries. Sub-blocks are treated like votes were treated before: the reward is scaled proportionally to the depth of the sub-block tree.
Example #%% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee v0([1]) --\u0026gt; s0[h] v2([2]) --\u0026gt; v1([1]) --\u0026gt; s0 s1[h\u0026#43;1] --\u0026gt; v0 \u0026amp; v2 s2[h\u0026#43;2] --\u0026gt; v5([3]) --\u0026gt; v4([2]) --\u0026gt; v3([1]) --\u0026gt; s1 s3[h\u0026#43;3] --\u0026gt; v8([1]) \u0026amp; v7([1]) \u0026amp; v6([1]) --\u0026gt; s2 v5a([2]):::orphan --\u0026gt; v3 s2a[h\u0026#43;2]:::orphan --\u0026gt; v4 \u0026amp; v5a v6a([1]):::orphan --\u0026gt; s2a linkStyle 15,16,17,18 opacity:0.5 Tailstorm with three sub-blocks per summary. Square boxes represent summary blocks and round boxes represent sub-blocks. Only sub-blocks require a proof-of-work. Summary blocks are labelled with their height, sub-blocks with their depth. The gray blocks are orphaned. Specification #Have a look at the methodology page for protocol specification to learn how to read this.
Parameters #k: number of sub-blocks per summary-block
Blockchain #def roots(): return [Block(height=0, depth=0, miner=None, kind=\u0026#34;summary\u0026#34;)] def parent_summary(b: Block): b = b.parents()[0] while b.kind != \u0026#34;summary\u0026#34;: b = b.parents()[0] return b def confirmed_sub_blocks(b: Block): set = {} for p in b.parents(): if p.kind == \u0026#34;sub-block\u0026#34;: set |= {p} set |= confirmed_sub_blocks(p) return set def confirming_sub_blocks(b: Block): set = {} for c in b.children(): if c.kind == \u0026#34;sub-block\u0026#34;: set |= {c} set |= confirming_sub_blocks(c) return set def validity(b: Block): if b.kind == \u0026#34;summary\u0026#34;: p = parent_summary(b) assert len(confirmed_sub_blocks(b)) == k assert b.height == p.height + 1 assert b.depth == 0 for x in confirmed_sub_blocks(b): assert parent_summary(x) == p elif b.kind == \u0026#34;sub-block\u0026#34;: parents = b.parents() assert len(parents) == 1 assert b.has_pow() assert b.depth == parents[0].depth + 1 return False Node #def init(roots: [Block]): return roots[0] def preference(old: Block, new: Block): assert new.kind == \u0026#34;summary\u0026#34; if new.height \u0026gt; old.height: return new if new.height \u0026lt; old.height: return old n_old = len(confirming_sub_blocks(old)) n_new = len(confirming_sub_blocks(new)) if n_new \u0026gt; n_old: return new if n_new \u0026lt; n_old: return old r_old = my_reward(old) r_new = my_reward(new) if r_new \u0026gt; n_old: return new return old def summarize(b: Block): assert b.kind == \u0026#34;block\u0026#34; if len(confirming_sub_blocks(b)) \u0026lt; k: return [] # summary infeasible else: # Select leaves in sub-block tree such that the tree includes # k sub-blocks and own-reward is maximized. leaves = ... return [ Block( kind=\u0026#34;summary\u0026#34;, height=b.height + 1, depth=0, parents=leaves, ) ] def update(old: Block, new: Block, event: string): if new.kind == \u0026#34;summary\u0026#34;: return Update(state=preference(old, new)) else: # new.kind == \u0026#34;sub-block\u0026#34; p = parent_summary(new) return Update( state=preference(old, p), share=[new] if event == \u0026#34;mining\u0026#34; else [], append=attempt_summary(p), ) def mining(b: Block): best = b for sb in confirming_sub_blocks(b): if sb.depth \u0026gt; p.depth or ( sb.depth == p.depth and p.miner == my_id ): best = sb return Block( kind=\u0026#34;sub-block\u0026#34;, depth=best.depth + 1, parents=[best], miner=my_id, ) Difficulty Adjustment #def progress(b: Block): return b.height * k + b.depth Rewards #def local_tip(b: Block): return b def global_tip(l: [Block]): b = l[0] for i in range(1, len(l)): b = preference(b, l[i]) return b def history(b: Block): h = [b] p = b.parents() while p != []: b = p[0] if b.kind == \u0026#34;summary\u0026#34;: h.append(b) p = b.parents() return h Constant reward #def constant_reward(b: Block): assert b.kind == \u0026#34;summary\u0026#34; return [Reward(x.miner, 1) for x in confirmed_sub_blocks(b)] %% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee v0([1]) --\u0026gt; s0[n/a] v2([1]) --\u0026gt; v1([1]) --\u0026gt; s0 s1[n/a] --\u0026gt; v0 \u0026amp; v2 s2[n/a] --\u0026gt; v5([1]) --\u0026gt; v4([1]) --\u0026gt; v3([1]) --\u0026gt; s1 s3[n/a] --\u0026gt; v8([1]) \u0026amp; v7([1]) \u0026amp; v6([1]) --\u0026gt; s2 v5a([n/a]):::orphan --\u0026gt; v3 s2a[n/a]:::orphan --\u0026gt; v4 \u0026amp; v5a v6a([n/a]):::orphan --\u0026gt; s2a linkStyle 15,16,17,18 opacity:0.5 Constant reward applied to the example blockchain shown above. Only the miners of sub-blocks get assigned rewards. Discount reward #def discount_reward(b: Block): assert b.kind == \u0026#34;summary\u0026#34; r = max([x.depth for x in b.parents()]) / k return [Reward(x.miner, r) for x in confirmed_sub_blocks(b)] %% Rendering this graph requires Javascript. graph RL classDef orphan opacity:0.5,fill:#eee v0([2/3]) --\u0026gt; s0[n/a] v2([2/3]) --\u0026gt; v1([2/3]) --\u0026gt; s0 s1[n/a] --\u0026gt; v0 \u0026amp; v2 s2[n/a] --\u0026gt; v5([3/3]) --\u0026gt; v4([3/3]) --\u0026gt; v3([3/3]) --\u0026gt; s1 s3[n/a] --\u0026gt; v8([1/3]) \u0026amp; v7([1/3]) \u0026amp; v6([1/3]) --\u0026gt; s2 v5a([n/a]):::orphan --\u0026gt; v3 s2a[n/a]:::orphan --\u0026gt; v4 \u0026amp; v5a v6a([n/a]):::orphan --\u0026gt; s2a linkStyle 15,16,17,18 opacity:0.5 Discount reward applied to the example blockchain shown above. Observe how the reward scheme punishes non-linearity. `}),e.add({id:13,href:"/cpr/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()